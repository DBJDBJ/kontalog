/*
 This code is (c) by dbj@dbj.org, CC BY SA 4.0
*/
// we log to console, that is all that one needs
// #define LOG_TO_FILE
#if DEBUG
#define DBJLOG_LEVEL_CHECK
#endif
//#define KONTALOG_HANDLES_SQLSVR_CLIENT_EXCEPTION

#region usings_declarations

#nullable enable
// #define LOG_TO_FILE
// above redirects Writeln to log.info and Writerr to log.error
// using System;
// using System.IO;
//using System;
//using System.Diagnostics;
//using System.IO;
using System;

using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;
using System.Threading;
using Microsoft.Extensions.Configuration;


// for adding Serilog must do this in the folder where the host project csproj is
// dbjcore is code reused
// $ dotnet add package Serilog
// $ dotnet add package Serilog.Sinks.Console
// $ dotnet add package Serilog.Sinks.File
using Serilog;
using static System.Runtime.InteropServices.JavaScript.JSType;

// use like this:
// using static DBJcore;
// after which you can just use the method names 
// from the class DBJcore in here
// without a class name and dot in the front, for example:
// Writeln( Whoami() );

#endregion usings_declarations

namespace dbjcore;

#region common utilities
// we keep it in the global names space
public sealed class DBJcore
{

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string my_domain(bool up_ = false)
    {
        Lazy<string> lazy_ = new Lazy<string>(
            () => Environment.UserDomainName.ToString()
        );
        return lazy_.Value;
    }

    /// <summary>
    /// Random word made from GUID
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string guid_word(bool up_ = false)
    {
        // wow, what a cludge, don't do this at home ;)
        // wait of 1 mili sec so that guids 
        // are sufficiently different
        System.Threading.Thread.Sleep(1);
        string input = Guid.NewGuid().ToString("N");
        input = up_ ? input.ToUpper() : input.ToLower();
        // remove numbers
        return Regex.Replace(input, @"[\d-]", string.Empty);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string local_now()
    {
        return DateTime.Now.ToLocalTime().ToString();
    }

    // Console.WriteLine("Hello my UTC timestamp      : " + iso8601(1));
    // Console.WriteLine("Hello iso8601 with 'T'      : " + iso8601(2));
    // Console.WriteLine("Hello full iso8601          : " + iso8601(3));
    // Console.WriteLine("Hello  my local timestamp   : " + iso8601());
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string iso8601(short kind_ = 0)
    {
        switch (kind_)
        {
            case 1:
                // no 'T' fromat e.g. "2023-07-15 05:56:27"
                return DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss", System.Globalization.CultureInfo.InvariantCulture);
            case 2:
                // official 'T' format e.g.  2023-07-15T07:56:27
                return DateTime.Now.ToLocalTime().ToString("s", System.Globalization.CultureInfo.InvariantCulture);
            case 3:
                // a sortable date/time pattern; conforms to ISO 8601.
                return DateTime.Now.ToLocalTime().ToString("o", System.Globalization.CultureInfo.InvariantCulture);
            default:
                // default e.g. 2023-07-15 07:56:27
                return DateTime.Now.ToLocalTime().ToString("yyyy-MM-dd HH:mm:ss", System.Globalization.CultureInfo.InvariantCulture);
        }
    }

    /// <summary>
    /// Return the name of the caller
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string Whoami([CallerMemberName] string? caller_name = null)
    {
        if (string.IsNullOrEmpty(caller_name))
            return "unknown";
        if (string.IsNullOrWhiteSpace(caller_name))
            return "unknown";
        return caller_name;
    }

    /// <summary>
    /// Return the file name and source line number to the caller
    /// returned is a record type
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (string File, int Line) FileLineInfo(
        [CallerFilePath] string filePath = "",
        [CallerLineNumber] int lineNumber = 0)
    {
        // make and return a record
        return new(filePath, lineNumber);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Assert(bool condition_)
    {
        System.Diagnostics.Debug.Assert(condition_);
        return condition_;
    }

    /// <summary>
    /// Return the name of this assebly or executable
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string ThisName()
    {
        return Assembly.GetExecutingAssembly().GetName().FullName;
    }

    /*
     * string test = "Testing 1-2-3";

    // convert string to stream
    byte[] byteArray = Encoding.ASCII.GetBytes(test);
    MemoryStream stream = new MemoryStream(byteArray);

    // convert stream to string
    StreamReader reader = new StreamReader(stream);
    string text = reader.ReadToEnd();
     */
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static System.IO.Stream ToStream(string sval_)
    {
        byte[] byteArray = Encoding.ASCII.GetBytes(sval_);
        return new MemoryStream(byteArray);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string ToString(System.IO.Stream sval_)
    {
        StreamReader reader = new StreamReader(sval_);
        return reader.ReadToEnd();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string ToUTF8(string sval_)
    {
        byte[] bytes = Encoding.Default.GetBytes(sval_);
        return Encoding.UTF8.GetString(bytes);
    }

    /// <summary>
    /// retun the local IP as a string
    /// if "127.0.0.1" is returned obviously there is no network
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string local_ip()
    {
        Lazy<string> lazyIP = new Lazy<string>(
            () =>
            {
                using (Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, 0))
                {
                    try
                    {
                        socket.Connect("8.8.8.8", 65530);
                        IPEndPoint endPoint = (IPEndPoint)socket.LocalEndPoint!;
                        return endPoint!.Address.ToString();
                    }
                    catch (Exception)
                    {
#if DEBUG
                        DBJLog.error($"No local IP found from the socket");
#endif
                        return "127.0.0.1";
                    }
                }
            }
        );

        return lazyIP.Value;
    }

} // Program_context

#endregion common utilities

///////////////////////////////////////////////////////////////////////////////////////
#region logging
///////////////////////////////////////////////////////////////////////////////////////

/*
do this in the folder where the host project csproj is

$ dotnet add package Serilog
$ dotnet add package Serilog.Sinks.Console
$ dotnet add package Serilog.Sinks.File
*/
public sealed class DBJLog : System.IDisposable
{
    public readonly static string text_line = "-------------------------------------------------------------------------------";
    public readonly static string app_friendly_name = System.AppDomain.CurrentDomain.FriendlyName;

    static string app_name
    {
        get
        {
            return app_friendly_name; //  app_friendly_name.Substring(0, app_friendly_name.IndexOf('.'));
        }
    }

    // is this a trick? hack? a cludge? no.
    // this method is deliberately not static
    // so that instance must be made to use it
    // Why? :wink:
    public Serilog.Events.LogEventLevel enabled_level()
    {
        if (Serilog.Log.IsEnabled(Serilog.Events.LogEventLevel.Verbose)) return Serilog.Events.LogEventLevel.Verbose;
        if (Serilog.Log.IsEnabled(Serilog.Events.LogEventLevel.Debug)) return Serilog.Events.LogEventLevel.Debug;
        if (Serilog.Log.IsEnabled(Serilog.Events.LogEventLevel.Information)) return Serilog.Events.LogEventLevel.Information;
        if (Serilog.Log.IsEnabled(Serilog.Events.LogEventLevel.Warning)) return Serilog.Events.LogEventLevel.Warning;
        if (Serilog.Log.IsEnabled(Serilog.Events.LogEventLevel.Error)) return Serilog.Events.LogEventLevel.Error;
        if (Serilog.Log.IsEnabled(Serilog.Events.LogEventLevel.Fatal)) return Serilog.Events.LogEventLevel.Fatal;

        // this is true example when exception has a role
        // in exceptional situations only
        throw new Exception("method " + DBJcore.Whoami() + ": This should never happen");

    }


#if LOG_TO_FILE
    // this path is obviously deeply wrong :P
    // ROADMAP: it will be externaly configurable
    public readonly static string log_file_path_template_ = "{0}logs\\{1}.log";
#endif
    public DBJLog()
    {
        // https://github.com/serilog/serilog/wiki/Configuration-Basics#minimum-level
        // default level is Information and that is considered for a production system

        // default is not file but console logging
        // all that container logging needs is to console only
        // that goes to container logs and is collected by log agents/dispatchers
#if LOG_TO_FILE
        string log_file_path_ = string.Format(log_file_path_template_, AppContext.BaseDirectory, app_name);
        Serilog.Log.Logger = new LoggerConfiguration()
           .WriteTo.File(log_file_path_, rollingInterval: RollingInterval.Day)
#if DEBUG
           .MinimumLevel.Debug()
#endif
           .CreateLogger();
#else
        Serilog.Log.Logger = new LoggerConfiguration()
#if DEBUG
    .MinimumLevel.Debug()
#else
    // WARNING: Serilog default level is Info, we move it to Fatal
    // in production we want only fatal messages
    .MinimumLevel.Fatal()
#endif
    .WriteTo.Console()
    .CreateLogger();
#endif

#if LOG_TO_FILE
        DBJLog.log_file_header(log_file_path_);
#endif

#if DEBUG
#if DBJLOG_LEVEL_CHECK
        // we found this as an very wellcome de-confuzor for many users
        Serilog.Events.LogEventLevel? what_level = enabled_level();

        Serilog.Log.Debug(" ");
        Serilog.Log.Debug("dbj_core: Log level check. Using Serilog");
        Serilog.Log.Debug(" ");
        Serilog.Log.Fatal("FATAL is on the top level");
        Serilog.Log.Error("ERROR is bellow FATAL");
        Serilog.Log.Warning("WARNING is bellow ERROR");
        Serilog.Log.Information("INFORMATION is bellow WARNING");
        Serilog.Log.Debug("DEBUG is bellow INFORMATION");
        Serilog.Log.Verbose("VERBOSE is on the bottom level");
        Serilog.Log.Debug(" ");
        Serilog.Log.Debug("dbj_core: this is DEBUG build and default is .MinimumLevel.Debug() ");
        Serilog.Log.Debug("dbj_core: result of enabled_level() is: " + what_level.ToString());
        Serilog.Log.Debug(" ");
        Serilog.Log.Debug("HINT: In production we want fatal level only.");
        Serilog.Log.Debug(" ");

        what_level = null;
        // if minimum level is DEBUG only Verbose will not be shown
        // https://github.com/serilog/serilog/wiki/Configuration-Basics#minimum-level
        // default level is Information; considered for a production 
#endif // DBJLOG_LEVEL_CHECK
#endif

    } // Main()

#if LOG_TO_FILE
    static void log_file_header(string log_file_path_)
    {
        Serilog.Log.Information(text_line);
        Serilog.Log.Information($"[{System.DateTime.Now.ToLocalTime().ToString()}] Starting {app_name}");
        Serilog.Log.Information($"Launched from {Environment.CurrentDirectory}");
        Serilog.Log.Information($"Physical location {AppDomain.CurrentDomain.BaseDirectory}");
#if DEBUG
        Serilog.Log.Debug($"AppContext.BaseDir {AppContext.BaseDirectory}");
        Serilog.Log.Debug("This app is built in a DEBUG mode");
#endif
        Serilog.Log.Information(text_line);
        ProcessModule? pm_ = Process.GetCurrentProcess().MainModule;
        if (pm_ != null)
        {
            Serilog.Log.Information($"Runtime Call {Path.GetDirectoryName(pm_.FileName)}");
        }
        Serilog.Log.Information($"Log file location:{log_file_path_}");
        Serilog.Log.Information(text_line);
    }
#endif

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal void debug_(string msg_)
    {
        Serilog.Log.Debug(msg_);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal void info_(string msg_) { Serilog.Log.Information(msg_); }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal void error_(string msg_) { Serilog.Log.Error(msg_); }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal void fatal_(string msg_) { Serilog.Log.Fatal(msg_); }

    // this is where log instance is made on demand once and not before called the first time
    static System.Lazy<DBJLog> lazy_log = new Lazy<DBJLog>(() => new DBJLog());
    private bool disposedValue;

    // use this to create the DBJLog instance (through its contructor) at least once 
    static public DBJLog logger { get { return lazy_log.Value; } }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void dispatch_(
        Action<string> log_, string format, params object[] args
        )
    {
        if (args.Length < 1)
            log_(format);
        else
        {
            log_(string.Format(format, args));
        }
    }

    // calling one of these will lazy load the loger and then use it
    // repeated calls will reuse the same instance
    // log.info("where is this going then?");
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void debug(string format, params object[] args)
    {
        dispatch_((msg_) => logger.debug_(msg_), format, args);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void info(string format, params object[] args)
    {
        dispatch_((msg_) => logger.info_(msg_), format, args);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void error(string format, params object[] args)
    {
        dispatch_((msg_) => logger.error_(msg_), format, args);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void fatal(string format, params object[] args)
    {
        dispatch_((msg_) => logger.fatal_(msg_), format, args);
    }
    //-----------------------------------------------------------------
    ~DBJLog()
    {
        Dispose(false);
    }

    private void Dispose(bool disposing)
    {
        if (!disposedValue)
        {
            if (disposing)
            {
                Serilog.Log.CloseAndFlush();
            }

            // TODO: free unmanaged resources (unmanaged objects) and override finalizer
            // TODO: set large fields to null
            disposedValue = true;
        }
    }

    // // TODO: override finalizer only if 'Dispose(bool disposing)' has code to free unmanaged resources
    // ~DBJLog()
    // {
    //     // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
    //     Dispose(disposing: false);
    // }

    void IDisposable.Dispose()
    {
        // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
        Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }

}

#endregion logging

///////////////////////////////////////////////////////////////////////////////////////
#region configuration
///////////////////////////////////////////////////////////////////////////////////////

/*

-------------------------------------------------------------------------------------------------------
We/I am use/ing json as config file format
------------------------------------------------------------------------------------------------------ -

Ditto in the proj file there must be information where is the config json file
and what is its name. Like so:
    
<ItemGroup>
<Content Include="appsettings.json">
<CopyToOutputDirectory>Always</CopyToOutputDirectory>
</Content>
</ItemGroup>

followed with section that adds the dot net components to use from the code

<ItemGroup>
<PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="6.0.0" />
<PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="7.0.0" />
<PackageReference Include="Microsoft.Extensions.Configuration.EnvironmentVariables" Version="7.0.0" />
</ItemGroup>
*/
public sealed class DBJCfg
{
    IConfiguration config;
    readonly string config_file_name = string.Empty;
    /*
    config file name is completely 100% arbitrary
    it is hidden as def. val constructor parameter

    I know that is not a good thing, but I am lazy , and besides that
    How to configure the congiguration? Externaly? Probably using the cli arguments?
    */
    public DBJCfg(string json_config_file = "appsettings.json")
    {
        config_file_name = json_config_file;
        // Build a config object, using env vars and JSON providers.
        config = new ConfigurationBuilder()
      .AddJsonFile(json_config_file)
      .AddEnvironmentVariables()
      .Build();
    }

    // given path return value as string or empty string 
    public string kpv(string path_)
    {
        try
        {
            var section_ = this.config.GetRequiredSection(path_);
#if DBJ_TRACE
            Log.info($"cfg {DBJcore.Whoami()}() for path: '{path_}'  -- key: '{section_.Key}', val: '{section_.Value}'");
#endif
            return section_.Value!;
        }
        catch (Exception x_)
        {
#if DEBUG
            DBJLog.error($"No element in the cfg json found for the path: '{path_}'");
#endif
            DBJLog.error(x_.ToString());
        }
        return string.Empty;
    }

    /* 
    given path return the value or default value cast to the required type
    */
    T read<T>(string path_, T default_)
    {
        try
        {
            var section_ = this.config.GetRequiredSection(path_);
#if DBJ_TRACE
            Log.info($"cfg {DBJcore.Whoami()}() -- path: '{path_}'  key:'{section_.Key}', val: '{section_.Value}'");
#endif
            if (typeof(T).IsValueType && default_ == null)
            {
                // Handle value types with null default values
                default_ = Activator.CreateInstance<T>();
            }
            return section_.Get<T>() ?? default_;
        }
        catch (Exception x_)
        {
#if DEBUG
            DBJLog.error($"No element found for the path: '{path_}'");
#endif
            DBJLog.error(x_.ToString());
        }
        return default_; // not: default(T)!;
    }

    // this is where cfg is made on demand once 
    // and not before it is called for the first time
    static Lazy<DBJCfg> lazy_cfg = new Lazy<DBJCfg>(() => new DBJCfg());

    static public DBJCfg instance { get { return lazy_cfg.Value; } }
    //
    // calling will lazy load the Configurator and then use it
    //
    // var ip1 = Cfg.get<string>("ip1", "192.168.0.0");
    //
    public static T get<T>(string path_, T dflt_) { return instance.read<T>(path_, dflt_); }

    public static string FileName { get { return instance.config_file_name; } }

} // Config standardorum superiorum

#endregion configuration
